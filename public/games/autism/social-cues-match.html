<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Social Cues Matching</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:wght@400;700&family=Nunito:wght@600;800;900&display=swap');

        :root {
            --bg-grad-dark: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            --bg-grad-light: linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%);
            --card-bg: rgba(255, 255, 255, 0.85);
            --card-dark: rgba(20, 30, 40, 0.7);
            --primary: #4A90E2;
            --primary-dark: #2a5298;
            --success: #38b000;
            --error: #e63946;
            --text-main: #2b2b2b;
            --text-light: #ffffff;
            --font-head: 'Nunito', sans-serif;
            --font-body: 'Atkinson Hyperlegible', sans-serif;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: var(--font-body);
            text-align: center;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-grad-light);
            color: var(--text-main);
            transition: background 0.5s ease, color 0.5s ease;
            overflow-x: hidden;
            padding: 20px 0;
        }

        body.dark { background: var(--bg-grad-dark); color: var(--text-light); }

        /* Top Controls */
        .header-controls {
            position: absolute; top: 20px; width: 100%; max-width: 900px;
            display: flex; justify-content: space-between; padding: 0 20px;
        }

        button.icon-btn {
            background: rgba(255, 255, 255, 0.2); backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.4); border-radius: 50px;
            padding: 8px 16px; font-family: var(--font-head); font-size: 1rem;
            cursor: pointer; color: inherit; transition: all 0.3s ease; font-weight: 800;
        }
        button.icon-btn:hover { transform: translateY(-2px); background: rgba(255, 255, 255, 0.4); }

        h1 {
            font-family: var(--font-head); font-size: clamp(1.8rem, 4vw, 2.8rem);
            font-weight: 900; margin: 40px 0 10px; text-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        #game-info {
            display: flex; gap: 20px; font-size: 1.2rem; font-weight: 700;
            margin-bottom: 10px; background: rgba(0,0,0,0.05);
            padding: 10px 25px; border-radius: 20px;
        }
        body.dark #game-info { background: rgba(255,255,255,0.1); }

        /* Main Container */
        #game-container {
            width: 95%; max-width: 850px; background: var(--card-bg);
            padding: 30px; border-radius: 24px; box-shadow: 0 20px 50px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.5);
            display: flex; flex-direction: column; align-items: center;
        }
        body.dark #game-container { background: var(--card-dark); border-color: rgba(255,255,255,0.1); }

        .scenario {
            background: rgba(0, 0, 0, 0.04); padding: 15px 25px; border-radius: 12px;
            margin-bottom: 20px; font-size: 1.2rem; font-weight: 700; width: 100%;
            display: flex; align-items: center; justify-content: center; gap: 10px;
        }
        body.dark .scenario { background: rgba(255, 255, 255, 0.05); }

        .read-btn { background: none; border: none; font-size: 1.5rem; cursor: pointer; transition: transform 0.2s; }
        .read-btn:hover { transform: scale(1.15); }

        /* Card Grid */
        .card-grid {
            display: grid; gap: 15px; width: 100%; margin-bottom: 20px;
            grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
            justify-items: center;
        }

        .card {
            width: 140px; height: 140px; perspective: 1000px; cursor: pointer;
        }

        .card-inner {
            position: relative; width: 100%; height: 100%; text-align: center;
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform-style: preserve-3d;
        }
        
        .card.flipped .card-inner { transform: rotateY(180deg); }
        .card.matched .card-inner { transform: rotateY(180deg) scale(0.95); opacity: 0.7; }
        
        .card-front, .card-back {
            position: absolute; width: 100%; height: 100%;
            -webkit-backface-visibility: hidden; backface-visibility: hidden;
            border-radius: 16px; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
        }

        .card-front {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: rgba(255,255,255,0.8); font-size: 3rem; font-weight: 900;
            border: 2px solid rgba(255,255,255,0.2);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .card:hover .card-front { transform: translateY(-3px); box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2); }

        .card-back {
            background: white; color: var(--text-main); transform: rotateY(180deg);
            padding: 10px; border: 3px solid var(--primary);
            flex-direction: column; gap: 5px;
        }
        body.dark .card-back { background: #1a1a1a; color: white; }

        .card-content-emoji { font-size: 3.5rem; line-height: 1; }
        .card-content-text { font-family: var(--font-head); font-size: 1rem; font-weight: 800; line-height: 1.2; word-wrap: break-word; }

        /* Progress & Messages */
        #message {
            margin-top: 15px; font-family: var(--font-head); font-size: 1.5rem;
            font-weight: 900; min-height: 35px; color: var(--success);
            animation: slideUp 0.3s ease;
        }

        .level-progress-bar {
            width: 100%; height: 10px; background-color: rgba(0, 0, 0, 0.1);
            border-radius: 10px; margin-top: 15px; overflow: hidden;
        }
        body.dark .level-progress-bar { background-color: rgba(255, 255, 255, 0.1); }
        .level-progress {
            height: 100%; background: linear-gradient(90deg, #4facfe, #00f2fe);
            width: 0%; transition: width 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .action-btn {
            margin-top: 20px; padding: 14px 35px; font-family: var(--font-head); font-size: 1.3rem; font-weight: 900;
            color: white; border: none; border-radius: 50px; cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease; box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }
        #restart-btn { background: var(--error); display:none; margin-top: 20px; }
        .action-btn:hover { transform: translateY(-3px); }

        @keyframes slideUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes popMatch { 0% { transform: scale(1); } 50% { transform: scale(1.15); box-shadow: 0 0 20px var(--success); } 100% { transform: scale(1); } }
        @keyframes shakeWrong { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 50% { transform: translateX(5px); } 75% { transform: translateX(-5px); } }
    </style>
</head>
<body class="light">

    <div class="header-controls">
        <button class="icon-btn" id="audio-toggle" onclick="toggleAudio()">üîä Sound: ON</button>
        <button class="icon-btn" id="theme-toggle" onclick="toggleTheme()">üåô Dark Mode</button>
    </div>

    <h1>Social Cues Matching</h1>
    <div id="game-info">
        <div>Level: <span id="level">1</span>/5</div>
        <div>Score: <span id="score">0</span></div>
    </div>

    <div id="game-container">
        
        <div id="welcome-screen">
            <h2 style="font-family: var(--font-head); margin-bottom: 15px;">Welcome to Social Matching!</h2>
            <p style="font-size: 1.1rem; line-height: 1.6; margin-bottom: 25px;">
                Flip the cards to find matching pairs. Match the feeling or social situation with the correct response!
            </p>
            <button class="action-btn" id="start-button" style="background: var(--primary);" onclick="startGame()">Start Playing ‚ñ∂</button>
        </div>

        <div id="play-area" style="display: none; width: 100%;">
            <div class="scenario">
                <button class="read-btn" onclick="speakText(document.getElementById('scenario-text').textContent)" title="Read Aloud">üì¢</button>
                <span id="scenario-text">Match the facial expressions with the correct emotions!</span>
            </div>
            
            <div class="card-grid" id="card-grid"></div>
            
            <div class="level-progress-bar">
                <div class="level-progress" id="progress"></div>
            </div>
        </div>

    </div>
    
    <div id="message"></div>
    <button class="action-btn" id="restart-btn" onclick="location.reload()">‚Ü∫ Restart Game</button>

    <script>
        // Database
        const levels = [
            {
                scenario: "Match the facial expressions with the correct emotions.",
                pairs: [
                    { emotion: "Happy", image: "üòÄ" },
                    { emotion: "Sad", image: "üò¢" },
                    { emotion: "Angry", image: "üò†" },
                    { emotion: "Surprised", image: "üòÆ" }
                ]
            },
            {
                scenario: "Can you match these subtle feelings?",
                pairs: [
                    { emotion: "Confused", image: "ü§î" },
                    { emotion: "Nervous", image: "üò∞" },
                    { emotion: "Proud", image: "üòå" },
                    { emotion: "Bored", image: "üòí" },
                    { emotion: "Excited", image: "ü§©" }
                ]
            },
            {
                scenario: "Match the social situation with the best response.",
                pairs: [
                    { emotion: "Someone says hello", image: "Wave and say hi" },
                    { emotion: "Someone looks sad", image: "Ask if they are okay" },
                    { emotion: "You receive a gift", image: "Say thank you" },
                    { emotion: "Someone is talking", image: "Listen quietly" }
                ]
            },
            {
                scenario: "Match the body language with what it means.",
                pairs: [
                    { emotion: "Arms crossed", image: "Defensive or closed" },
                    { emotion: "Leaning forward", image: "Interested" },
                    { emotion: "Looking away", image: "Distracted" },
                    { emotion: "Tapping foot", image: "Impatient" },
                    { emotion: "Smiling with eye contact", image: "Friendly" }
                ]
            },
            {
                scenario: "Match these complex social scenarios!",
                pairs: [
                    { emotion: "Friend seems upset", image: "Check in on them" },
                    { emotion: "Group is laughing", image: "Smile and join in" },
                    { emotion: "Someone interrupts you", image: "Wait for a pause" },
                    { emotion: "Meeting someone new", image: "Introduce yourself" },
                    { emotion: "Someone disagrees", image: "Listen to them" }
                ]
            }
        ];

        // Game State
        let level = 1;
        let score = 0;
        let flippedCards = [];
        let matchedPairs = 0;
        let totalPairs = 0;
        let canFlip = true;
        let audioEnabled = true;

        // Audio System
        function playTone(type) {
            if (!audioEnabled) return;
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain); gain.connect(ctx.destination);
                
                if (type === 'flip') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.1, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                    osc.start(); osc.stop(ctx.currentTime + 0.1);
                } else if (type === 'match') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(523.25, ctx.currentTime); // C5
                    osc.frequency.setValueAtTime(659.25, ctx.currentTime + 0.1); // E5
                    gain.gain.setValueAtTime(0.2, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                    osc.start(); osc.stop(ctx.currentTime + 0.3);
                } else if (type === 'wrong') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(150, ctx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.15, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                    osc.start(); osc.stop(ctx.currentTime + 0.2);
                } else if (type === 'levelup') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(440, ctx.currentTime);
                    osc.frequency.setValueAtTime(554.37, ctx.currentTime + 0.1);
                    osc.frequency.setValueAtTime(659.25, ctx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.15, ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.5);
                    osc.start(); osc.stop(ctx.currentTime + 0.5);
                }
            } catch(e) {}
        }

        function speakText(text) {
            if (!audioEnabled || !window.speechSynthesis) return;
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 1;
            window.speechSynthesis.speak(utterance);
        }

        // Toggles
        function toggleTheme() {
            const body = document.body;
            const btn = document.getElementById('theme-toggle');
            if (body.classList.contains('dark')) {
                body.classList.replace('dark', 'light');
                btn.textContent = 'üåô Dark Mode';
            } else {
                body.classList.replace('light', 'dark');
                btn.textContent = '‚òÄÔ∏è Light Mode';
            }
        }

        function toggleAudio() {
            audioEnabled = !audioEnabled;
            document.getElementById('audio-toggle').textContent = audioEnabled ? 'üîä Sound: ON' : 'üîá Sound: OFF';
            if(!audioEnabled) window.speechSynthesis.cancel();
        }

        // --- Core Logic ---
        function updateUI() {
            document.getElementById('level').textContent = level;
            document.getElementById('score').textContent = score;
            document.getElementById('progress').style.width = `${(matchedPairs / totalPairs) * 100}%`;
        }

        function isEmoji(str) {
            const regex = /[\p{Emoji_Presentation}\p{Extended_Pictographic}]/gu;
            return regex.test(str);
        }

        function createCard(content, type, index) {
            const card = document.createElement('div');
            card.className = 'card';
            card.dataset.index = index;
            card.dataset.type = type;
            
            const cardInner = document.createElement('div');
            cardInner.className = 'card-inner';
            
            const cardFront = document.createElement('div');
            cardFront.className = 'card-front';
            cardFront.textContent = '?';
            
            const cardBack = document.createElement('div');
            cardBack.className = 'card-back';
            
            // Format content based on whether it is an emoji or text
            if (isEmoji(content) && content.length <= 2) {
                const emj = document.createElement('div');
                emj.className = 'card-content-emoji';
                emj.textContent = content;
                cardBack.appendChild(emj);
            } else {
                const txt = document.createElement('div');
                txt.className = 'card-content-text';
                txt.textContent = content;
                cardBack.appendChild(txt);
            }
            
            cardInner.appendChild(cardFront);
            cardInner.appendChild(cardBack);
            card.appendChild(cardInner);
            
            card.addEventListener('click', () => handleCardClick(card, content));
            return card;
        }

        function handleCardClick(card, contentText) {
            if (!canFlip || card.classList.contains('flipped') || card.classList.contains('matched')) return;
            
            playTone('flip');
            card.classList.add('flipped');
            flippedCards.push(card);
            
            // Speak content
            if(!isEmoji(contentText) || contentText.length > 2) {
                speakText(contentText);
            }
            
            if (flippedCards.length === 2) {
                canFlip = false;
                checkForMatch();
            }
        }

        function checkForMatch() {
            const [card1, card2] = flippedCards;
            const isMatch = card1.dataset.index === card2.dataset.index;
            
            setTimeout(() => {
                if (isMatch) {
                    playTone('match');
                    card1.classList.add('matched');
                    card2.classList.add('matched');
                    
                    // Add success animation to inner card
                    card1.querySelector('.card-inner').style.animation = "popMatch 0.5s ease";
                    card2.querySelector('.card-inner').style.animation = "popMatch 0.5s ease";

                    matchedPairs++;
                    score += 10;
                    updateUI();
                    
                    if (matchedPairs === totalPairs) {
                        setTimeout(levelComplete, 600);
                    }
                } else {
                    playTone('wrong');
                    // Add shake animation
                    card1.querySelector('.card-inner').style.animation = "shakeWrong 0.4s ease";
                    card2.querySelector('.card-inner').style.animation = "shakeWrong 0.4s ease";
                    
                    setTimeout(() => {
                        card1.classList.remove('flipped');
                        card2.classList.remove('flipped');
                        card1.querySelector('.card-inner').style.animation = "";
                        card2.querySelector('.card-inner').style.animation = "";
                    }, 500);
                }
                
                flippedCards = [];
                canFlip = true;
            }, 900);
        }

        function levelComplete() {
            const msg = document.getElementById('message');
            playTone('levelup');
            
            if (level < levels.length) {
                msg.textContent = `üåü Level ${level} Complete!`;
                msg.style.display = 'block';
                level++;
                
                setTimeout(() => {
                    msg.style.display = 'none';
                    setupLevel();
                }, 2000);
            } else {
                msg.textContent = `üèÜ Incredible! You finished the game!`;
                speakText("Incredible! You finished the game!");
                document.getElementById('restart-btn').style.display = 'block';
            }
        }

        function setupLevel() {
            const currentLevel = levels[level - 1];
            const cardGrid = document.getElementById('card-grid');
            
            // Reset state
            cardGrid.innerHTML = '';
            matchedPairs = 0;
            flippedCards = [];
            canFlip = true;
            
            // Setup Text
            document.getElementById('scenario-text').textContent = currentLevel.scenario;
            speakText(currentLevel.scenario);
            
            const pairs = currentLevel.pairs;
            totalPairs = pairs.length;
            
            // Create deck
            let cards = [];
            pairs.forEach((pair, index) => {
                cards.push({ content: pair.emotion, type: 'emotion', index });
                cards.push({ content: pair.image, type: 'image', index });
            });
            
            // Shuffle
            cards = cards.sort(() => 0.5 - Math.random());
            
            // Set CSS Grid layout dynamically based on card count
            if(cards.length <= 8) {
                cardGrid.style.gridTemplateColumns = `repeat(4, 1fr)`;
            } else {
                cardGrid.style.gridTemplateColumns = `repeat(5, 1fr)`;
            }
            
            cards.forEach(card => {
                cardGrid.appendChild(createCard(card.content, card.type, card.index));
            });
            
            updateUI();
        }

        function startGame() {
            // Unlock audio context
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                ctx.resume();
            } catch(e) {}

            document.getElementById('welcome-screen').style.display = 'none';
            document.getElementById('play-area').style.display = 'block';
            
            level = 1;
            score = 0;
            setupLevel();
        }

        // Init UI
        updateUI();
    </script>
</body>
</html>